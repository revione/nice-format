<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Formatter</title>
    <link rel="stylesheet" href="./styles.css" />
  </head>

  <body>
    <div class="instructions">💡 <strong>Instrucciones:</strong> Presiona <kbd>Cmd+1</kbd> para modo oscuro</div>

    <div class="controls">
      <div class="font-controls">
        <label for="fontSizeRange">Tamaño de fuente:</label>
        <span id="fontSizeValue">24px</span>
        <input type="range" id="fontSizeRange" min="12" max="48" value="24" oninput="adjustFormatterFontSize()" />
      </div>
      <button class="copy-button" onclick="copyFormatterText()">📋 Copiar Texto</button>
    </div>

    <textarea id="formatter" class="formatter">
Am frühen Morgen, während des Frühstücks und beim Aufräumen im Wohnzimmer, bemerkte die Frau, dass ihr neues Foto vom gestern aufgenommenen Garten schon im Album ist, obwohl der Drucker wieder nicht funktioniert. Sie hatte am Vortag durchs Fenster ein aufgenommenes Bild gemacht und danach ein freundliches, hellgrünes Kleidungsstück fürs heutige Treffen ausgewählt. Zum zweiten Mal in dieser Woche war sie pünktlich gewesen, und trotz der lauten Werbung im Radio blieb sie ruhig; sowohl der Kaffee als auch die Musik waren warm, entweder sie arbeitet jetzt oder sie wartet noch kurz ab—nicht nur die Ordnung, sondern auch die Übersicht hilft.

Wir sehen hier das Gesehene: ein aufgenommenes Bild, das weder unscharf noch schief ist, sondern klar, ruhig und technisch sauber ausgerichtet. Die mittleren Farbtöne wirken natürlich, die Form des ovalen Gesichts mit ausgeprägten Wangenknochen passt gut zum sanften Lächeln; man sieht einige der oberen Zähne, die gut ausgerichtet zu sein scheinen. Neben der Person liegt eine kleine Umhängetasche, vorm Plakat steht ein ausdrucksstarkes Herzsymbol, das jemand nachts hingelegt hat. Im Hintergrund erkennt man eine Grünfläche mit weitläufiger Vegetation, die sich bis zum Winkel des Gartentors erstreckt; dorthin geht sie gleich, hinein mit der Kamera, später wieder heraus. Das Fenster ist geöffnet (Zustandspassiv), wird aber gleich geschlossen (Vorgangspassiv); zuvor war es schon geöffnet worden.

Erst gegen 10:30 Uhr kommt ihr Bruder, der Hubsan-Drohnen mag, vor das Haus. Er fragt: „Sehen wir uns die neuen Aufnahmen später an, oder gehst du lieber hinauf ins Zimmer, um zu arbeiten?" Sie antwortet: „Nein, lieber nicht—ich will erst die 30. Datei sortieren und die zweite Serie ergänzen; danach gehe ich eher hinaus, weil das Licht jetzt besser ist. Wenn ich mehr Zeit hätte, würde ich heute die hundertste Aufnahme prüfen; könnte ich, würde ich auch die Farben neu kalibrieren." In der Mailbox blinkt eine E-Mail, deren Betreff „okay, finish later" lautet, womit sie sich später beschäftigt.

Später geht sie hinunter in den Keller, wo ein Lesesessel in der Leseecke steht; dort schreibt sie eine kurze Notiz auf Deutsch und eine englische Randbemerkung („okay, finish later") — die sie vielleicht löscht. Nachdem sie die Aufgaben geordnet hatte, wurde das Fenster geöffnet und wieder geschlossen; das geöffnete Fenster lässt frische Luft hinein, während der Computer im Arbeitszimmer weiter rechnet. Als ob sie gestern nichts erledigt hätte, erinnert sie sich doch daran, dass sie bereits zweimal produktiv gewesen ist. Öffne die Mappe, speichere die Änderungen, drucke die Testseite! notiert sie für sich als kleine To-do-Liste.

Draußen geht sie ein paar Schritte hinüber zum Schuppen, kommt dann herüber, holt die Kamera heraus, legt sie hinein und nimmt sie später wieder heraus; sie steht auf, räumt auf und macht weiter. Sie mag das Licht, will fertig werden, muss aber noch warten: Sie wird die Serie morgen abschließen (Futur I) und bis dahin alles sortiert haben (Futur II). Das Ergebnis ist besser, vielleicht am besten am späten Nachmittag; die größere Datei ist 3,5 MB schwer, die kleinste kaum 120 kB. Kein Besucher, keine Störung und keinem Gerät fehlt heute etwas.

Im Ordner liegen verschiedene Dokumente: die Möglichkeit, die Freundlichkeit, eine Entscheidung, eine Beschreibung, ein Ergebnis—alles Neue neben manchem Alten. Sie bekommt Hilfe, versteht die Einstellungen und bezahlt die Lizenz; später entwirft sie einen Plan, zerlegt ein Problem in Schritte und erreicht schließlich, was sie erreichen wollte. Wegen des Wetters bleibt sie drinnen, innerhalb der nächsten Stunde sortiert sie weiter; außerhalb des Hauses wird es leiser, unterm Tisch schnurrt der Rechner. „Doch, es ist wirklich ziemlich gut geworden—und morgen wird es wohl noch besser werden", sagt sie leise und würde, wenn es sein müsste, alles noch einmal machen, ohne unnötig zurückzugehen, statt zuzusehen, um die Serie abzuschließen—und dann vielleicht das Paket abzuholen.
</textarea
    >

    <div id="colored-text" style="display: none">
      <h3>🎨 Texto Analizado</h3>
      <div class="learn-instructions">💡 <strong>Hover sobre una palabra y presiona:</strong> <kbd>D</kbd> para agregar a lista de aprender | <kbd>F</kbd> para quitar de lista de aprender</div>
      <div id="colored-content"></div>
    </div>

    <div id="learn-words" style="display: none">
      <h3>
        📚 Palabras para Aprender
        <span class="total-words" id="learn-count">(0 palabras)</span>
      </h3>
      <div id="learn-word-list"></div>
    </div>

    <div id="word-count" style="display: none">
      <h3>
        📊 Frecuencia de Palabras
        <span class="total-words" id="total-words"></span>
      </h3>

      <div class="filter-checkboxes">
        <div class="filter-controls">
          <div class="filter-buttons">
            <button class="filter-control-btn" onclick="selectAllFilters()">✅ Seleccionar todos</button>
            <button class="filter-control-btn" onclick="clearAllFilters()">❌ Limpiar todos</button>
          </div>
          <div class="filter-status" id="filter-status">Mostrando: 0 palabras únicas (0 tipos seleccionados)</div>
        </div>

        <div class="filter-item">
          <input type="checkbox" id="filter-verb" data-type="verb" checked />
          <label for="filter-verb" id="label-verb">🔴 Verbos (0)</label>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-noun" data-type="noun" checked />
          <label for="filter-noun" id="label-noun">🔵 Sustantivos (0)</label>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-article" data-type="article" checked />
          <label for="filter-article" id="label-article">🟡 Artículos (0)</label>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-adjective" data-type="adjective" checked />
          <label for="filter-adjective" id="label-adjective">🟠 Adjetivos (0)</label>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-pronoun" data-type="pronoun" checked />
          <label for="filter-pronoun" id="label-pronoun">🟢 Pronombres (0)</label>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-preposition" data-type="preposition" checked />
          <label for="filter-preposition" id="label-preposition">🟣 Preposiciones (0)</label>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-conjunction" data-type="conjunction" checked />
          <label for="filter-conjunction" id="label-conjunction">🟤 Conjunciones (0)</label>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-adverb" data-type="adverb" checked />
          <label for="filter-adverb" id="label-adverb">🟪 Adverbios (0)</label>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-number" data-type="number" checked />
          <label for="filter-number" id="label-number">🔢 Números (0)</label>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-foreign" data-type="foreign" checked />
          <label for="filter-foreign" id="label-foreign">🌍 Extranjeros (0)</label>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-ambiguous" data-type="ambiguous" checked />
          <label for="filter-ambiguous" id="label-ambiguous">🔶 Ambiguas (0)</label>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-other" data-type="other" checked />
          <label for="filter-other" id="label-other">⚫ Otras (0)</label>
        </div>
      </div>

      <div class="legend">
        <div class="legend-item">
          <small>💡 Usa los filtros arriba para mostrar/ocultar tipos de palabras (conteo de palabras únicas)</small>
        </div>
      </div>

      <div id="word-list"></div>
    </div>

    <script src="./front/toggleDark.js"></script>
    <script src="./front/windowFunctions.js"></script>

    <script type="module">
      import { identifyWordType, identifyWord, classifyTokens } from "./identifyWord.js";
      import { WORD_TYPES } from "./word-types/types.js";

      const MorphologicalAnalyzer = () => {
        let wordsToLearn = new Set();
        let currentActiveWord = null;

        const displayLearnWords = () => {
          const learnWordsDiv = document.getElementById("learn-words");
          const learnWordListDiv = document.getElementById("learn-word-list");
          const learnCountSpan = document.getElementById("learn-count");

          if (wordsToLearn.size === 0) {
            learnWordsDiv.style.display = "none";
            return;
          }

          learnCountSpan.textContent = `(${wordsToLearn.size} palabras)`;
          learnWordListDiv.innerHTML = "";

          const wordsArray = Array.from(wordsToLearn).sort();

          wordsArray.forEach((wordData) => {
            const [word, type] = wordData.split("|");

            const getTypeStyle = (typeId) => {
              const typeObj = Object.values(WORD_TYPES).find((t) => t.id === typeId);
              return typeObj || WORD_TYPES.OTHER;
            };

            const typeStyle = getTypeStyle(type);

            const wordItem = document.createElement("div");
            wordItem.className = "learn-word-item";

            wordItem.innerHTML = `
              <div>
                <span class="learn-word-text">
                  <span style="margin-right: 8px;" title="${typeStyle.label}">${typeStyle.emoji}</span>
                  ${word}
                </span>
                <span class="learn-word-type">${typeStyle.label}</span>
              </div>
              <button class="remove-word-btn" onclick="removeWordToLearn('${word}', '${type}')" title="Quitar de lista">
                x
              </button>
            `;

            learnWordListDiv.appendChild(wordItem);
          });

          learnWordsDiv.style.display = "block";
        };

        const addWordToLearn = (word, type) => {
          const wordKey = `${word}|${type}`;
          wordsToLearn.add(wordKey);
          displayLearnWords();
          updateWordHighlights();
        };

        window.removeWordToLearn = (word, type) => {
          const wordKey = `${word}|${type}`;
          wordsToLearn.delete(wordKey);
          displayLearnWords();
          updateWordHighlights();
        };

        const updateWordHighlights = () => {
          const coloredWords = document.querySelectorAll(".word-colored");
          coloredWords.forEach((span) => {
            const word = span.textContent.toLowerCase();
            const type = span.className.match(/word-(\w+)/)?.[1];
            const wordKey = `${word}|${type}`;

            if (wordsToLearn.has(wordKey)) {
              span.classList.add("word-learning");
            } else {
              span.classList.remove("word-learning");
            }
          });
        };

        const handleKeyPress = (event) => {
          if (!currentActiveWord) return;

          if (event.key.toLowerCase() === "d") {
            event.preventDefault();
            const word = currentActiveWord.textContent.toLowerCase();
            const type = currentActiveWord.dataset.type;
            if (word && type) {
              addWordToLearn(word, type);
            }
          } else if (event.key.toLowerCase() === "f") {
            event.preventDefault();
            const word = currentActiveWord.textContent.toLowerCase();
            const type = currentActiveWord.className.match(/word-(\w+)/)?.[1];
            if (word && type) {
              window.removeWordToLearn(word, type);
            }
          }
        };

        const identifyWordTypeWithCase = (lowerWord, originalWord, isFirstWord, tokens, currentIndex, sentence) => {
          if (lowerWord === "wolle") {
            return originalWord[0] === originalWord[0].toUpperCase() ? "noun" : "verb";
          }

          return identifyWord(originalWord, {
            atSentenceStart: isFirstWord,
            tokens,
            currentIndex,
            sentence,
          }).type;
        };

        // Exponer función global para otros scripts
        window.updateWordCount = () => {
          const formatter = document.getElementById("formatter");
          const text = formatter.value || "";
          const wordCount = countWords(text);
          displayWordCount(wordCount, text);
        };

        // Resto de las funciones del analizador...
        const countWords = (text) => {
          if (!text.trim()) return {};

          let cleanText = text.replace(/\r?\n/g, " ").replace(/\r/g, " ").replace(/\s+/g, " ").trim();

          const sentences = cleanText.split(/[.!?]+/);
          const wordCount = {};

          sentences.forEach((sentence) => {
            if (!sentence.trim()) return;

            const rawWords = sentence.trim().replace(/[–—]/g, " ").split(/\s+/);
            const tokensForSentence = rawWords.map((w) => w.replace(/[^\p{L}\p{N}\s.\-]/gu, "")).filter((w) => w.length >= 1);

            let idx = 0;

            rawWords.forEach((originalWord) => {
              const clean = originalWord.replace(/[^\p{L}\p{N}\s-]/gu, "");
              if (clean.length >= 1) {
                const lower = clean.toLowerCase();
                const isFirst = idx === 0;

                const type = identifyWordTypeWithCase(lower, clean, isFirst, tokensForSentence, idx, sentence);

                if (!wordCount[lower]) wordCount[lower] = { count: 0, type };
                wordCount[lower].count++;

                idx++;
              }
            });
          });

          return wordCount;
        };

        const getActiveFilters = () => {
          const checkboxes = document.querySelectorAll('.filter-checkboxes input[type="checkbox"]:checked');
          return Array.from(checkboxes).map((cb) => cb.dataset.type);
        };

        const createColoredText = (text) => {
          const coloredTextDiv = document.getElementById("colored-text");
          const coloredContentDiv = document.getElementById("colored-content");

          if (!text.trim()) {
            coloredTextDiv.style.display = "none";
            return;
          }

          const activeFilters = getActiveFilters();
          const sentences = text.split(/([.!?]+)/);
          let coloredHTML = "";

          sentences.forEach((sentence) => {
            if (/[.!?]+/.test(sentence)) {
              coloredHTML += sentence;
              return;
            }

            const words = sentence.split(/(\s+)/);
            const analysisTokens = words
              .filter((w) => w.trim())
              .map((w) => w.replace(/[^\p{L}\p{N}\s-]/gu, ""))
              .filter((w) => w.length >= 1);

            let analysisIndex = 0;

            words.forEach((word) => {
              if (word.trim()) {
                const cleanWord = word.replace(/[^\p{L}\p{N}\s-]/gu, "");
                if (cleanWord.length >= 1) {
                  const isFirstWord = analysisIndex === 0;
                  const lowerWord = cleanWord.toLowerCase();

                  const type = identifyWordTypeWithCase(lowerWord, cleanWord, isFirstWord, analysisTokens, analysisIndex, sentence);

                  analysisIndex++;

                  const getTypeStyle = (typeId) => {
                    const typeObj = Object.values(WORD_TYPES).find((t) => t.id === typeId);
                    return typeObj || WORD_TYPES.OTHER;
                  };

                  const typeStyle = getTypeStyle(type);

                  if (activeFilters.includes(type)) {
                    coloredHTML += `<span class="word-colored word-${type}" data-tooltip="${typeStyle.label}: ${cleanWord}" data-word="${lowerWord}" data-type="${type}">${word}</span>`;
                  } else {
                    coloredHTML += word;
                  }
                } else {
                  coloredHTML += word;
                }
              } else {
                coloredHTML += word;
              }
            });
          });

          coloredContentDiv.innerHTML = coloredHTML;

          const coloredWords = coloredContentDiv.querySelectorAll(".word-colored");
          coloredWords.forEach((span) => {
            span.addEventListener("mouseenter", () => {
              currentActiveWord = span;
              span.classList.add("word-active");
            });

            span.addEventListener("mouseleave", () => {
              currentActiveWord = null;
              span.classList.remove("word-active");
            });
          });

          updateWordHighlights();
          coloredTextDiv.style.display = "block";
        };

        const updateFilterCounts = (wordCount) => {
          const typeCounts = {
            verb: 0,
            noun: 0,
            article: 0,
            adjective: 0,
            pronoun: 0,
            preposition: 0,
            conjunction: 0,
            adverb: 0,
            number: 0,
            foreign: 0,
            ambiguous: 0,
            other: 0,
          };

          Object.entries(wordCount).forEach(([word, data]) => {
            if (typeCounts.hasOwnProperty(data.type)) {
              typeCounts[data.type] += 1;
            }
          });

          Object.keys(typeCounts).forEach((type) => {
            const label = document.getElementById(`label-${type}`);
            if (label) {
              const emoji = label.textContent.split(" ")[0];
              const name = label.textContent.split(" ")[1];
              label.textContent = `${emoji} ${name} (${typeCounts[type]})`;
            }
          });

          const activeFilters = getActiveFilters();
          const totalFilteredUniqueWords = Object.entries(wordCount).filter(([word, data]) => activeFilters.includes(data.type)).length;

          const statusElement = document.getElementById("filter-status");
          statusElement.textContent = `Mostrando: ${totalFilteredUniqueWords} palabras únicas (${activeFilters.length} tipos seleccionados)`;
        };

        const displayWordCount = (wordCount, text = "") => {
          const wordCountDiv = document.getElementById("word-count");
          const wordListDiv = document.getElementById("word-list");
          const totalWordsSpan = document.getElementById("total-words");

          const totalWords = Object.values(wordCount).reduce((sum, item) => sum + item.count, 0);
          const uniqueWords = Object.keys(wordCount).length;

          if (uniqueWords === 0) {
            wordCountDiv.style.display = "none";
            return;
          }

          totalWordsSpan.textContent = `${totalWords} palabras totales, ${uniqueWords} únicas`;

          updateFilterCounts(wordCount);
          createColoredText(text);

          const sortedWords = Object.entries(wordCount).sort(([, a], [, b]) => b.count - a.count);
          const activeFilters = getActiveFilters();
          const filteredWords = sortedWords.filter(([word, data]) => activeFilters.includes(data.type));

          wordListDiv.innerHTML = "";

          filteredWords.forEach(([word, data]) => {
            const wordItem = document.createElement("div");
            wordItem.className = "word-item";

            const getTypeStyle = (typeId) => {
              const type = Object.values(WORD_TYPES).find((t) => t.id === typeId);
              return type || WORD_TYPES.OTHER;
            };

            const typeStyle = getTypeStyle(data.type);

            wordItem.innerHTML = `
              <span class="word-text">
                <span style="margin-right: 5px;" title="${typeStyle.label}">${typeStyle.emoji}</span>
                ${word}
              </span>
              <span class="word-count-number" style="background-color: ${typeStyle.color}">
                ${data.count}
              </span>
            `;

            wordListDiv.appendChild(wordItem);
          });

          wordCountDiv.style.display = "block";
        };

        // Inicialización del analizador
        const setupEventListeners = () => {
          const formatter = document.getElementById("formatter");

          formatter.addEventListener("input", window.updateWordCount);
          formatter.addEventListener("paste", () => {
            setTimeout(window.updateWordCount, 100);
          });
          formatter.addEventListener("keyup", window.updateWordCount);
          formatter.addEventListener("focus", window.updateWordCount);
          formatter.addEventListener("blur", window.updateWordCount);

          const filterCheckboxes = document.querySelectorAll('.filter-checkboxes input[type="checkbox"]');
          filterCheckboxes.forEach((checkbox) => {
            checkbox.addEventListener("change", () => {
              const formatter = document.getElementById("formatter");
              const text = formatter.value || "";
              const wordCount = countWords(text);
              displayWordCount(wordCount, text);
            });
          });

          document.addEventListener("keydown", handleKeyPress);
        };

        setupEventListeners();
        window.updateWordCount();
      };

      document.addEventListener("DOMContentLoaded", MorphologicalAnalyzer);
    </script>
  </body>
</html>
