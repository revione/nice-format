<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Formatter</title>
    <link rel="stylesheet" href="./styles.css" />
  </head>

  <body>
    <div class="instructions">ğŸ’¡ <strong>Instrucciones:</strong> Presiona <kbd>Cmd+1</kbd> para modo oscuro</div>

    <div class="controls">
      <div class="font-controls">
        <label for="fontSizeRange">TamaÃ±o de fuente:</label>
        <span id="fontSizeValue">24px</span>
        <input type="range" id="fontSizeRange" min="12" max="48" value="24" oninput="adjustFormatterFontSize()" />
      </div>
      <button class="copy-button" onclick="copyFormatterText()">ğŸ“‹ Copiar Texto</button>
    </div>

    <textarea id="formatter" class="formatter">
Am frÃ¼hen Morgen, wÃ¤hrend des FrÃ¼hstÃ¼cks und beim AufrÃ¤umen im Wohnzimmer, bemerkte die Frau, dass ihr neues Foto vom gestern aufgenommenen Garten schon im Album ist, obwohl der Drucker wieder nicht funktioniert. Sie hatte am Vortag durchs Fenster ein aufgenommenes Bild gemacht und danach ein freundliches, hellgrÃ¼nes KleidungsstÃ¼ck fÃ¼rs heutige Treffen ausgewÃ¤hlt. Zum zweiten Mal in dieser Woche war sie pÃ¼nktlich gewesen, und trotz der lauten Werbung im Radio blieb sie ruhig; sowohl der Kaffee als auch die Musik waren warm, entweder sie arbeitet jetzt oder sie wartet noch kurz abâ€”nicht nur die Ordnung, sondern auch die Ãœbersicht hilft.

Wir sehen hier das Gesehene: ein aufgenommenes Bild, das weder unscharf noch schief ist, sondern klar, ruhig und technisch sauber ausgerichtet. Die mittleren FarbtÃ¶ne wirken natÃ¼rlich, die Form des ovalen Gesichts mit ausgeprÃ¤gten Wangenknochen passt gut zum sanften LÃ¤cheln; man sieht einige der oberen ZÃ¤hne, die gut ausgerichtet zu sein scheinen. Neben der Person liegt eine kleine UmhÃ¤ngetasche, vorm Plakat steht ein ausdrucksstarkes Herzsymbol, das jemand nachts hingelegt hat. Im Hintergrund erkennt man eine GrÃ¼nflÃ¤che mit weitlÃ¤ufiger Vegetation, die sich bis zum Winkel des Gartentors erstreckt; dorthin geht sie gleich, hinein mit der Kamera, spÃ¤ter wieder heraus. Das Fenster ist geÃ¶ffnet (Zustandspassiv), wird aber gleich geschlossen (Vorgangspassiv); zuvor war es schon geÃ¶ffnet worden.

Erst gegen 10:30 Uhr kommt ihr Bruder, der Hubsan-Drohnen mag, vor das Haus. Er fragt: â€Sehen wir uns die neuen Aufnahmen spÃ¤ter an, oder gehst du lieber hinauf ins Zimmer, um zu arbeiten?" Sie antwortet: â€Nein, lieber nichtâ€”ich will erst die 30. Datei sortieren und die zweite Serie ergÃ¤nzen; danach gehe ich eher hinaus, weil das Licht jetzt besser ist. Wenn ich mehr Zeit hÃ¤tte, wÃ¼rde ich heute die hundertste Aufnahme prÃ¼fen; kÃ¶nnte ich, wÃ¼rde ich auch die Farben neu kalibrieren." In der Mailbox blinkt eine E-Mail, deren Betreff â€okay, finish later" lautet, womit sie sich spÃ¤ter beschÃ¤ftigt.

SpÃ¤ter geht sie hinunter in den Keller, wo ein Lesesessel in der Leseecke steht; dort schreibt sie eine kurze Notiz auf Deutsch und eine englische Randbemerkung (â€okay, finish later") â€” die sie vielleicht lÃ¶scht. Nachdem sie die Aufgaben geordnet hatte, wurde das Fenster geÃ¶ffnet und wieder geschlossen; das geÃ¶ffnete Fenster lÃ¤sst frische Luft hinein, wÃ¤hrend der Computer im Arbeitszimmer weiter rechnet. Als ob sie gestern nichts erledigt hÃ¤tte, erinnert sie sich doch daran, dass sie bereits zweimal produktiv gewesen ist. Ã–ffne die Mappe, speichere die Ã„nderungen, drucke die Testseite! notiert sie fÃ¼r sich als kleine To-do-Liste.

DrauÃŸen geht sie ein paar Schritte hinÃ¼ber zum Schuppen, kommt dann herÃ¼ber, holt die Kamera heraus, legt sie hinein und nimmt sie spÃ¤ter wieder heraus; sie steht auf, rÃ¤umt auf und macht weiter. Sie mag das Licht, will fertig werden, muss aber noch warten: Sie wird die Serie morgen abschlieÃŸen (Futur I) und bis dahin alles sortiert haben (Futur II). Das Ergebnis ist besser, vielleicht am besten am spÃ¤ten Nachmittag; die grÃ¶ÃŸere Datei ist 3,5 MB schwer, die kleinste kaum 120 kB. Kein Besucher, keine StÃ¶rung und keinem GerÃ¤t fehlt heute etwas.

Im Ordner liegen verschiedene Dokumente: die MÃ¶glichkeit, die Freundlichkeit, eine Entscheidung, eine Beschreibung, ein Ergebnisâ€”alles Neue neben manchem Alten. Sie bekommt Hilfe, versteht die Einstellungen und bezahlt die Lizenz; spÃ¤ter entwirft sie einen Plan, zerlegt ein Problem in Schritte und erreicht schlieÃŸlich, was sie erreichen wollte. Wegen des Wetters bleibt sie drinnen, innerhalb der nÃ¤chsten Stunde sortiert sie weiter; auÃŸerhalb des Hauses wird es leiser, unterm Tisch schnurrt der Rechner. â€Doch, es ist wirklich ziemlich gut gewordenâ€”und morgen wird es wohl noch besser werden", sagt sie leise und wÃ¼rde, wenn es sein mÃ¼sste, alles noch einmal machen, ohne unnÃ¶tig zurÃ¼ckzugehen, statt zuzusehen, um die Serie abzuschlieÃŸenâ€”und dann vielleicht das Paket abzuholen.
</textarea
    >

    <div id="colored-text" style="display: none">
      <h3>ğŸ¨ Texto Analizado</h3>
      <div class="learn-instructions">ğŸ’¡ <strong>Hover sobre una palabra y presiona:</strong> <kbd>D</kbd> para agregar a lista de aprender | <kbd>F</kbd> para quitar de lista de aprender</div>
      <div id="colored-content"></div>
    </div>

    <div id="learn-words" style="display: none">
      <h3>
        ğŸ“š Palabras para Aprender
        <span class="total-words" id="learn-count">(0 palabras)</span>
      </h3>
      <div id="learn-word-list"></div>
    </div>

    <div id="word-count" style="display: none">
      <h3>
        ğŸ“Š Frecuencia de Palabras
        <span class="total-words" id="total-words"></span>
      </h3>

      <div class="filter-checkboxes">
        <div class="filter-controls">
          <div class="filter-buttons">
            <button class="filter-control-btn" onclick="selectAllFilters()">âœ… Seleccionar todos</button>
            <button class="filter-control-btn" onclick="clearAllFilters()">âŒ Limpiar todos</button>
          </div>
          <div class="filter-status" id="filter-status">Mostrando: 0 palabras Ãºnicas (0 tipos seleccionados)</div>
        </div>

        <div class="filter-item">
          <input type="checkbox" id="filter-verb" data-type="verb" checked />
          <label for="filter-verb" id="label-verb">ğŸ”´ Verbos (0)</label>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-noun" data-type="noun" checked />
          <label for="filter-noun" id="label-noun">ğŸ”µ Sustantivos (0)</label>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-article" data-type="article" checked />
          <label for="filter-article" id="label-article">ğŸŸ¡ ArtÃ­culos (0)</label>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-adjective" data-type="adjective" checked />
          <label for="filter-adjective" id="label-adjective">ğŸŸ  Adjetivos (0)</label>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-pronoun" data-type="pronoun" checked />
          <label for="filter-pronoun" id="label-pronoun">ğŸŸ¢ Pronombres (0)</label>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-preposition" data-type="preposition" checked />
          <label for="filter-preposition" id="label-preposition">ğŸŸ£ Preposiciones (0)</label>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-conjunction" data-type="conjunction" checked />
          <label for="filter-conjunction" id="label-conjunction">ğŸŸ¤ Conjunciones (0)</label>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-adverb" data-type="adverb" checked />
          <label for="filter-adverb" id="label-adverb">ğŸŸª Adverbios (0)</label>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-number" data-type="number" checked />
          <label for="filter-number" id="label-number">ğŸ”¢ NÃºmeros (0)</label>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-foreign" data-type="foreign" checked />
          <label for="filter-foreign" id="label-foreign">ğŸŒ Extranjeros (0)</label>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-ambiguous" data-type="ambiguous" checked />
          <label for="filter-ambiguous" id="label-ambiguous">ğŸ”¶ Ambiguas (0)</label>
        </div>
        <div class="filter-item">
          <input type="checkbox" id="filter-other" data-type="other" checked />
          <label for="filter-other" id="label-other">âš« Otras (0)</label>
        </div>
      </div>

      <div class="legend">
        <div class="legend-item">
          <small>ğŸ’¡ Usa los filtros arriba para mostrar/ocultar tipos de palabras (conteo de palabras Ãºnicas)</small>
        </div>
      </div>

      <div id="word-list"></div>
    </div>

    <script src="./front/toggleDark.js"></script>
    <script src="./front/windowFunctions.js"></script>

    <script type="module">
      import { identifyWordType, identifyWord, classifyTokens } from "./identifyWord.js";
      import { WORD_TYPES } from "./word-types/types.js";

      const MorphologicalAnalyzer = () => {
        let wordsToLearn = new Set();
        let currentActiveWord = null;

        const displayLearnWords = () => {
          const learnWordsDiv = document.getElementById("learn-words");
          const learnWordListDiv = document.getElementById("learn-word-list");
          const learnCountSpan = document.getElementById("learn-count");

          if (wordsToLearn.size === 0) {
            learnWordsDiv.style.display = "none";
            return;
          }

          learnCountSpan.textContent = `(${wordsToLearn.size} palabras)`;
          learnWordListDiv.innerHTML = "";

          const wordsArray = Array.from(wordsToLearn).sort();

          wordsArray.forEach((wordData) => {
            const [word, type] = wordData.split("|");

            const getTypeStyle = (typeId) => {
              const typeObj = Object.values(WORD_TYPES).find((t) => t.id === typeId);
              return typeObj || WORD_TYPES.OTHER;
            };

            const typeStyle = getTypeStyle(type);

            const wordItem = document.createElement("div");
            wordItem.className = "learn-word-item";

            wordItem.innerHTML = `
              <div>
                <span class="learn-word-text">
                  <span style="margin-right: 8px;" title="${typeStyle.label}">${typeStyle.emoji}</span>
                  ${word}
                </span>
                <span class="learn-word-type">${typeStyle.label}</span>
              </div>
              <button class="remove-word-btn" onclick="removeWordToLearn('${word}', '${type}')" title="Quitar de lista">
                x
              </button>
            `;

            learnWordListDiv.appendChild(wordItem);
          });

          learnWordsDiv.style.display = "block";
        };

        const addWordToLearn = (word, type) => {
          const wordKey = `${word}|${type}`;
          wordsToLearn.add(wordKey);
          displayLearnWords();
          updateWordHighlights();
        };

        window.removeWordToLearn = (word, type) => {
          const wordKey = `${word}|${type}`;
          wordsToLearn.delete(wordKey);
          displayLearnWords();
          updateWordHighlights();
        };

        const updateWordHighlights = () => {
          const coloredWords = document.querySelectorAll(".word-colored");
          coloredWords.forEach((span) => {
            const word = span.textContent.toLowerCase();
            const type = span.className.match(/word-(\w+)/)?.[1];
            const wordKey = `${word}|${type}`;

            if (wordsToLearn.has(wordKey)) {
              span.classList.add("word-learning");
            } else {
              span.classList.remove("word-learning");
            }
          });
        };

        const handleKeyPress = (event) => {
          if (!currentActiveWord) return;

          if (event.key.toLowerCase() === "d") {
            event.preventDefault();
            const word = currentActiveWord.textContent.toLowerCase();
            const type = currentActiveWord.dataset.type;
            if (word && type) {
              addWordToLearn(word, type);
            }
          } else if (event.key.toLowerCase() === "f") {
            event.preventDefault();
            const word = currentActiveWord.textContent.toLowerCase();
            const type = currentActiveWord.className.match(/word-(\w+)/)?.[1];
            if (word && type) {
              window.removeWordToLearn(word, type);
            }
          }
        };

        const identifyWordTypeWithCase = (lowerWord, originalWord, isFirstWord, tokens, currentIndex, sentence) => {
          if (lowerWord === "wolle") {
            return originalWord[0] === originalWord[0].toUpperCase() ? "noun" : "verb";
          }

          return identifyWord(originalWord, {
            atSentenceStart: isFirstWord,
            tokens,
            currentIndex,
            sentence,
          }).type;
        };

        // Exponer funciÃ³n global para otros scripts
        window.updateWordCount = () => {
          const formatter = document.getElementById("formatter");
          const text = formatter.value || "";
          const wordCount = countWords(text);
          displayWordCount(wordCount, text);
        };

        // Resto de las funciones del analizador...
        const countWords = (text) => {
          if (!text.trim()) return {};

          let cleanText = text.replace(/\r?\n/g, " ").replace(/\r/g, " ").replace(/\s+/g, " ").trim();

          const sentences = cleanText.split(/[.!?]+/);
          const wordCount = {};

          sentences.forEach((sentence) => {
            if (!sentence.trim()) return;

            const rawWords = sentence.trim().replace(/[â€“â€”]/g, " ").split(/\s+/);
            const tokensForSentence = rawWords.map((w) => w.replace(/[^\p{L}\p{N}\s.\-]/gu, "")).filter((w) => w.length >= 1);

            let idx = 0;

            rawWords.forEach((originalWord) => {
              const clean = originalWord.replace(/[^\p{L}\p{N}\s-]/gu, "");
              if (clean.length >= 1) {
                const lower = clean.toLowerCase();
                const isFirst = idx === 0;

                const type = identifyWordTypeWithCase(lower, clean, isFirst, tokensForSentence, idx, sentence);

                if (!wordCount[lower]) wordCount[lower] = { count: 0, type };
                wordCount[lower].count++;

                idx++;
              }
            });
          });

          return wordCount;
        };

        const getActiveFilters = () => {
          const checkboxes = document.querySelectorAll('.filter-checkboxes input[type="checkbox"]:checked');
          return Array.from(checkboxes).map((cb) => cb.dataset.type);
        };

        const createColoredText = (text) => {
          const coloredTextDiv = document.getElementById("colored-text");
          const coloredContentDiv = document.getElementById("colored-content");

          if (!text.trim()) {
            coloredTextDiv.style.display = "none";
            return;
          }

          const activeFilters = getActiveFilters();
          const sentences = text.split(/([.!?]+)/);
          let coloredHTML = "";

          sentences.forEach((sentence) => {
            if (/[.!?]+/.test(sentence)) {
              coloredHTML += sentence;
              return;
            }

            const words = sentence.split(/(\s+)/);
            const analysisTokens = words
              .filter((w) => w.trim())
              .map((w) => w.replace(/[^\p{L}\p{N}\s-]/gu, ""))
              .filter((w) => w.length >= 1);

            let analysisIndex = 0;

            words.forEach((word) => {
              if (word.trim()) {
                const cleanWord = word.replace(/[^\p{L}\p{N}\s-]/gu, "");
                if (cleanWord.length >= 1) {
                  const isFirstWord = analysisIndex === 0;
                  const lowerWord = cleanWord.toLowerCase();

                  const type = identifyWordTypeWithCase(lowerWord, cleanWord, isFirstWord, analysisTokens, analysisIndex, sentence);

                  analysisIndex++;

                  const getTypeStyle = (typeId) => {
                    const typeObj = Object.values(WORD_TYPES).find((t) => t.id === typeId);
                    return typeObj || WORD_TYPES.OTHER;
                  };

                  const typeStyle = getTypeStyle(type);

                  if (activeFilters.includes(type)) {
                    coloredHTML += `<span class="word-colored word-${type}" data-tooltip="${typeStyle.label}: ${cleanWord}" data-word="${lowerWord}" data-type="${type}">${word}</span>`;
                  } else {
                    coloredHTML += word;
                  }
                } else {
                  coloredHTML += word;
                }
              } else {
                coloredHTML += word;
              }
            });
          });

          coloredContentDiv.innerHTML = coloredHTML;

          const coloredWords = coloredContentDiv.querySelectorAll(".word-colored");
          coloredWords.forEach((span) => {
            span.addEventListener("mouseenter", () => {
              currentActiveWord = span;
              span.classList.add("word-active");
            });

            span.addEventListener("mouseleave", () => {
              currentActiveWord = null;
              span.classList.remove("word-active");
            });
          });

          updateWordHighlights();
          coloredTextDiv.style.display = "block";
        };

        const updateFilterCounts = (wordCount) => {
          const typeCounts = {
            verb: 0,
            noun: 0,
            article: 0,
            adjective: 0,
            pronoun: 0,
            preposition: 0,
            conjunction: 0,
            adverb: 0,
            number: 0,
            foreign: 0,
            ambiguous: 0,
            other: 0,
          };

          Object.entries(wordCount).forEach(([word, data]) => {
            if (typeCounts.hasOwnProperty(data.type)) {
              typeCounts[data.type] += 1;
            }
          });

          Object.keys(typeCounts).forEach((type) => {
            const label = document.getElementById(`label-${type}`);
            if (label) {
              const emoji = label.textContent.split(" ")[0];
              const name = label.textContent.split(" ")[1];
              label.textContent = `${emoji} ${name} (${typeCounts[type]})`;
            }
          });

          const activeFilters = getActiveFilters();
          const totalFilteredUniqueWords = Object.entries(wordCount).filter(([word, data]) => activeFilters.includes(data.type)).length;

          const statusElement = document.getElementById("filter-status");
          statusElement.textContent = `Mostrando: ${totalFilteredUniqueWords} palabras Ãºnicas (${activeFilters.length} tipos seleccionados)`;
        };

        const displayWordCount = (wordCount, text = "") => {
          const wordCountDiv = document.getElementById("word-count");
          const wordListDiv = document.getElementById("word-list");
          const totalWordsSpan = document.getElementById("total-words");

          const totalWords = Object.values(wordCount).reduce((sum, item) => sum + item.count, 0);
          const uniqueWords = Object.keys(wordCount).length;

          if (uniqueWords === 0) {
            wordCountDiv.style.display = "none";
            return;
          }

          totalWordsSpan.textContent = `${totalWords} palabras totales, ${uniqueWords} Ãºnicas`;

          updateFilterCounts(wordCount);
          createColoredText(text);

          const sortedWords = Object.entries(wordCount).sort(([, a], [, b]) => b.count - a.count);
          const activeFilters = getActiveFilters();
          const filteredWords = sortedWords.filter(([word, data]) => activeFilters.includes(data.type));

          wordListDiv.innerHTML = "";

          filteredWords.forEach(([word, data]) => {
            const wordItem = document.createElement("div");
            wordItem.className = "word-item";

            const getTypeStyle = (typeId) => {
              const type = Object.values(WORD_TYPES).find((t) => t.id === typeId);
              return type || WORD_TYPES.OTHER;
            };

            const typeStyle = getTypeStyle(data.type);

            wordItem.innerHTML = `
              <span class="word-text">
                <span style="margin-right: 5px;" title="${typeStyle.label}">${typeStyle.emoji}</span>
                ${word}
              </span>
              <span class="word-count-number" style="background-color: ${typeStyle.color}">
                ${data.count}
              </span>
            `;

            wordListDiv.appendChild(wordItem);
          });

          wordCountDiv.style.display = "block";
        };

        // InicializaciÃ³n del analizador
        const setupEventListeners = () => {
          const formatter = document.getElementById("formatter");

          formatter.addEventListener("input", window.updateWordCount);
          formatter.addEventListener("paste", () => {
            setTimeout(window.updateWordCount, 100);
          });
          formatter.addEventListener("keyup", window.updateWordCount);
          formatter.addEventListener("focus", window.updateWordCount);
          formatter.addEventListener("blur", window.updateWordCount);

          const filterCheckboxes = document.querySelectorAll('.filter-checkboxes input[type="checkbox"]');
          filterCheckboxes.forEach((checkbox) => {
            checkbox.addEventListener("change", () => {
              const formatter = document.getElementById("formatter");
              const text = formatter.value || "";
              const wordCount = countWords(text);
              displayWordCount(wordCount, text);
            });
          });

          document.addEventListener("keydown", handleKeyPress);
        };

        setupEventListeners();
        window.updateWordCount();
      };

      document.addEventListener("DOMContentLoaded", MorphologicalAnalyzer);
    </script>
  </body>
</html>
